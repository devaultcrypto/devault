// Copyright (c) 2018 The Bitcoin developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include <chainparams.h>
#include <config.h>
#include <catch_tests/test_bitcoin.h>
#include <validation.h>

#include "catch_unit.h"

// BOOST_FIXTURE_TEST_SUITE(finalization_tests, TestChain100Setup)

TEST_CASE("finalizationDelay") {
  TestChain100Setup setup;
  CScript p2pk_scriptPubKey = CScript() << ToByteVector(setup.coinbaseKey.GetPubKey()) << OP_CHECKSIG;
  CBlock block;

  {
    LOCK(cs_main);
    // We should have no finalized block because the 100 blocks generated by
    // the test setup are too close to "now";
    std::cout << (GetFinalizedBlock() == nullptr) << " No block finalized (tip at height " << chainActive.Tip()->nHeight
              << ")\n";
  }

  // Create maxreorgdepth blocks. Auto-finalization will not occur because
  // the delay is not expired
  int64_t mockedTime = GetTime();
  for (uint32_t i = 0; i < DEFAULT_MAX_REORG_DEPTH; i++) {
    block = setup.CreateAndProcessBlock({}, p2pk_scriptPubKey);
    LOCK(cs_main);
    // These blocks are too recent.
    std::cout << (GetFinalizedBlock() == nullptr) << "No block finalized (tip at height " << chainActive.Tip()->nHeight
              << ")\n";
  }

  // Make the finalization time to expire
  mockedTime += DEFAULT_MIN_FINALIZATION_DELAY + 1;
  SetMockTime(mockedTime);

  // Next maxreorgdepth blocks should cause auto-finalization
  CBlockIndex *blockToFinalize = chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - DEFAULT_MAX_REORG_DEPTH);

  for (uint32_t i = 0; i < DEFAULT_MAX_REORG_DEPTH; i++) {
    blockToFinalize = chainActive.Next(blockToFinalize);
    block = setup.CreateAndProcessBlock({}, p2pk_scriptPubKey);
    LOCK(cs_main);
    std::cout << (GetFinalizedBlock() == blockToFinalize) << "Block finalized at height " << blockToFinalize->nHeight
              << " (tip at height " << chainActive.Tip()->nHeight << ")\n";
  }

  // Next blocks won't cause auto-finalization because the delay is not
  // expired
  for (uint32_t i = 0; i < DEFAULT_MAX_REORG_DEPTH; i++) {
    block = setup.CreateAndProcessBlock({}, p2pk_scriptPubKey);
    LOCK(cs_main);
    // These blocks are finalized.
    std::cout << (GetFinalizedBlock() == blockToFinalize) << "Finalized block remains unchanged at height "
              << blockToFinalize->nHeight << " (tip at height " << chainActive.Tip()->nHeight << ")\n";
  }

  // Make the finalization time to expire
  mockedTime += DEFAULT_MIN_FINALIZATION_DELAY + 1;
  SetMockTime(mockedTime);

  blockToFinalize = chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - DEFAULT_MAX_REORG_DEPTH);

  // Create some more blocks.
  // Finalization should start moving again.
  for (uint32_t i = 0; i < DEFAULT_MAX_REORG_DEPTH; i++) {
    blockToFinalize = chainActive.Next(blockToFinalize);
    block = setup.CreateAndProcessBlock({}, p2pk_scriptPubKey);
    LOCK(cs_main);
    std::cout << (GetFinalizedBlock() == blockToFinalize) << "Block finalized at height " << blockToFinalize->nHeight
              << " (tip at height " << chainActive.Tip()->nHeight << ")\n";
  }
}

// BOOST_AUTO_TEST_SUITE_END()
